module：一个 .py 文件就是个 module;
package：就是个带 __init__.py 的文件夹，并不在乎里面有什么，不过一般来讲会包含一些 packages/modules;
1、类属于模块的一部分。当我们要建立一个类时，通常我们新建一个py文件，例如新建立cn.py,这个cn便成为我们的模块。

2、然后在cn里面建立自己的类：

刚开始学Python的时候, 看到if __name__ == '__main__': main()就不明觉厉了, 一直好奇__name__这货到底是个什么东东

实际上, __name__是Python中模块的内置属性, 除此之外, 经常用到的还有__file__, __doc__, __all__, __package__等等


无点，绝对导入，先从从sys.path中找
有点，相对导入，先从当前目录的包中找
细节就不清楚了，反正想对导入用起来麻烦点



你会发现我们在这个MemberAuth类中根本就没有继承或者定义age属性，但是因为混入技术，可以直接拿其他基类的LoginAuth的age属性来判断，这样的代码在c++中是编译都过不了的。

python的这种灵活性给我们写项目时带来了一些便利，比如老板要对某一些情况，增加一个功能，我们甚至无须修改原有的代码，直接在运行时动态添加一个继承类到基类中，这样直接实例中就可以使用了，而且这个动态添加的继承类还能调用原有其他基类的属性和方法，而无需事先定义它。

但是mixin混入技术也有显著的不足之处：
1、编辑器无法通过联想获取实例的方法，通俗点就是，我们不能通过输入 "." 来让编辑器联想当前实例所具有的属性和方法了，因为这是运行时决定的，所以编辑器无能为力了，只能自己手动写。
2、如果几个不相干的类被mixin混入，那么其他人拿到你的代码，开始看你的混入类定义会比较迷茫，明明没有定义的属性和方法，怎么可以在类中随处调用。
3、动态混入肯定不是没有开销的，它的执行性能必然没有直接多重继承来的好，下面是测试代码：




